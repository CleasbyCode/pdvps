
Two scripts are embedded within the default PNG polyglot file.

1. Linux and Windows shell/batch script, with PowerShell commands (this runs first).
2. Main PowerShell Script.

The Linux and Windows shell/batch commands run first. This is in two parts:-

A. Linux shell + PowerShell commands.
B. Windows batch + PowerShell commands.

Found near top of PNG image within the "bKGD" chunk.

In a nutshell, these commands do the following for both Linux and Windows:-

1. Create a new directory "pdvps_extracted" in the current directory.
2. Read in all bytes from the original PNG polyglot file.
3. Modify a number of bytes in the PNG file to add PowerShell Comment-block 
strings to the beginning '<#' and end '#>' of the PNG file.

4. Write this modified file to disk as "pdvps_tmp.ps1" (PowerShell file) within the "pdvps_extracted" directory.
5. Move the original PNG polyglot image file into the "pdvps_extracted" directory.
6. Change into the "pdvps_extracted" directory.
7. Get PowerShell to run the "pdvps_tmp.ps1" file, which will start the main PowerShell script embedded in the image.

bKGD chunk

REM;clear;export pdvps_file="$0";echo 'Clear-Host;New-Item pdvps_extracted -itemtype directory;
$bt=[System.IO.File]::ReadAllBytes($env:pdvps_file);$bt[0]=0x0d;$bt[1]=0x3c;$bt[2]=0x23;
$bt[$bt.Length-3]=0x0d;$bt[$bt.Length-2]=0x23;$bt[$bt.Length-1]=0x3e;
[System.IO.File]::WriteAllBytes("./pdvps_extracted/pdvps_tmp.ps1", $bt);
Move-Item $env:pdvps_file -Destination pdvps_extracted -Force;
Set-Location pdvps_extracted;./pdvps_tmp.ps1'|pwsh;read -p "Press Enter to Exit.";clear;exit;
#&cls&powershell Clear-Host;New-Item pdvps_extracted -itemtype directory;
$bt=[System.IO.File]::ReadAllBytes('%~dpnx0');$bt[0]=0x0d;$bt[1]=0x3c;$bt[2]=0x23;
$bt[$bt.Length-3]=0x0d;$bt[$bt.Length-2]=0x23;$bt[$bt.Length-1]=0x3e;
[System.IO.File]::WriteAllBytes('.\pdvps_extracted\pdvps_tmp.ps1', $bt);
Move-Item '"%~dpnx0"' -Destination .\pdvps_extracted\pdv_image.png -Force;
Set-Location .\pdvps_extracted\;powershell -executionpolicy bypass -file .\pdvps_tmp.ps1&cls&exit

A. Linux Part

REM; # used by Windows to ignore the Linux part...
clear;
export pdvps_file="$0";

# This long echo command contains a number of Powershell commands which it |pipes to the Linux pwsh (PowerShell) program

echo 'Clear-Host;
	New-Item pdvps_extracted -itemtype directory;		# (1)
	$bt=[System.IO.File]::ReadAllBytes($env:pdvps_file);	# (2)
	$bt[0]=0x0d;						# (3)
	$bt[1]=0x3c;						# (3)
	$bt[2]=0x23;						# (3)
	$bt[$bt.Length-3]=0x0d;					# (3)	
	$bt[$bt.Length-2]=0x23;					# (3)
	$bt[$bt.Length-1]=0x3e;					# (3)
	[System.IO.File]::WriteAllBytes("./pdvps_extracted/pdvps_tmp.ps1", $bt);	# (4)
	Move-Item $env:pdvps_file -Destination pdvps_extracted -Force;			# (5)
	Set-Location pdvps_extracted;							# (6)
	./pdvps_tmp.ps1'|pwsh;					# (7)

read -p "Press Enter to Exit.";
clear;
exit;

B. Windows Part

#&cls
&powershell Clear-Host;
New-Item pdvps_extracted -itemtype directory;  	# (1)
$bt=[System.IO.File]::ReadAllBytes('%~dpnx0'); 	# (2)
$bt[0]=0x0d;					# (3)
$bt[1]=0x3c;					# (3)
$bt[2]=0x23;					# (3)	
$bt[$bt.Length-3]=0x0d;	 			# (3)
$bt[$bt.Length-2]=0x23;  			# (3)
$bt[$bt.Length-1]=0x3e;				# (3)
[System.IO.File]::WriteAllBytes('.\pdvps_extracted\pdvps_tmp.ps1', $bt);	# (4)
Move-Item '"%~dpnx0"' -Destination .\pdvps_extracted\pdv_image.png -Force;	# (5)
Set-Location .\pdvps_extracted\;						# (6)	
powershell -executionpolicy bypass -file .\pdvps_tmp.ps1			# (7)
&cls
&exit

Main PowerShell Script

Found after the embedded, 'encrypted' (xor) user data file within the "hIST" Chunk, before the "IDAT" chunk.

The PowerShell script will basically "cut" the user data file out of the PNG polyglot image
and write it to disk as a new file, it will then attempt to open/play/run the file (depending on media type).

Again, in a nutshell, the PowerShell script does the following (for both Linux and Windows).

1. Read in all the bytes from file "pdvps_tmp.ps1" and store in the $bt array
2. Start "repair code" on bytes if required (see comments below on "repair code").
3. Decrypt embedded user data file. (Simple XOR).
4. Store user file in $trunc, taken from $bt array.
5. Remove "pdvps_tmp.ps1" file.
6. Write the contents of $trunc (user media file) to disk. 
7. Open/Play/Run the extracted media file, depending on its type.

hIST chunk

<The user data file will be embedded here, before the main PowerShell script>

PDVPS

#>
Clear-Host;$os='Win';$tr=2043;$fl=;$ext='';$app=0;$m='media_file'+$ext;if($ext -eq '.py'){$app='python3 '};
$wa='';$la='';if(Test-Path -Path '/usr/bin'){$os='Linux';if($ext -eq '.ps1'){$app='pwsh '}}else{if($ext -eq '.ps1'){$app='powershell '}};
if($ext -eq '.ps1' -And $os -eq 'Win'){$m='.\'+$m};$ver=$PSVersionTable.PSVersion.Major;
if($ver -lt 5){Write-Host "`r`nError: PowerShell Version 5 or later is required.";
Start-Sleep -Seconds 6;exit};$pn=$MyInvocation.MyCommand.Definition;$n=$MyInvocation.MyCommand.Name;$bt=[System.IO.File]::ReadAllBytes($pn);
Write-Host "Decrypting Media File...";$j=704;for($i=$tr; $fl+$tr -gt $i;){$bt[$i]=$bt[$i] -bxor $bt[$j];$i++;$j--;if($j -lt 3) {$j=704}};
Clear-Host;$trunc=$bt[$tr..($fl+$tr-1)];Remove-Item $pn;$mp=$pn.Replace($n, $m);if(Test-Path -Path $mp){Remove-Item -Path $mp -Force;
Start-Sleep -Seconds 1};if($ver -gt 5) {Set-Content -value $trunc -AsByteStream -path "$($mp)"}
else{Set-Content -value $trunc -encoding byte -path "$($mp)"};
if($os -eq 'Linux'){if($app){$app+$m,$la |sh}elseif($ext -eq '.exe'){chmod +x $m;iex ./$m$la}
else{chmod -x $m; ii $m}}else{if($app){&cmd /c $app$m$wa;Pause}elseif($ext -eq '.exe'){&cmd /c $m$wa;Pause}else{ii $m}}
<#

#> End comment-block, start of main PowerShell script, interpret what follows....

Clear-Host;
$os='Win';

$tr=2043;	# $tr TRuncate variable const value. 
		# $bt array stores the whole PNG file, $tr sets the index location for the start of the embedded user media file in $bt. 

$fl=;		# $fl user File Length variable value (bytes) updated by C++ program.
		# Tells PowerShell how many bytes to read from the start index ($tr) of the $bt array.
		# This should be the entirety of the embedded user file, which is stored in $trunc 

$ext='';	# User file extension variable, updated by C++ program, e.g. ($ext='.mp4').

$app=0;

$m='media_file'+$ext;

if($ext -eq '.py')
	{$app='python3 '};

$wa='';		# $wa, Windows Arguments, command-line arguments string variable, updated by C++ program
$la='';    	# $la, Linux Arguments, command-line arguments string variable, updated by C++ program.
		# Only '.py', '.ps1' and '.exe' files get the option of adding command-line arguments for their embedded files.

if(Test-Path -Path '/usr/bin')
	{$os='Linux';
		if($ext -eq '.ps1')
	{$app='pwsh '}}
else{if($ext -eq '.ps1')
	{$app='powershell '}};
if($ext -eq '.ps1' -And $os -eq 'Win')
	{$m='.\'+$m};
$ver=$PSVersionTable.PSVersion.Major;

if($ver -lt 5)
	{Write-Host "`r`nError: PowerShell Version 5 or later is required.";
	Start-Sleep -Seconds 6;exit};
	
$pn=$MyInvocation.MyCommand.Definition;
$n=$MyInvocation.MyCommand.Name;

$bt=[System.IO.File]::ReadAllBytes($pn);	# (1)

--------------------------------------------------------------------------------------------------
<Repair code inserted here, if required>	# (2)

# If required, PowerShell 'repair code' for the user data file gets inserted here, 
# by the C++ program. The user data file CANNOT contain any occurrence of the PowerShell
# End Comment-Block string '#>'. This will cause the embedded PowerShell script to fail if
# it encounters that string anywhere in the user file. 

# The C++ program will check the file and if found, modify a byte for every occurrence
# of this string. It will store index locations of each modified byte in a larger string
# containing PowerShell code, which will put back the original '#' character that was changed,
# before writing the extracted user file to disk.

# (2)
# Start of repair code example...

$i=-1;

# PowerShell array containing index location values for each byte to change back
# (index values created by C++ program).

$idx=@(1002,2381,38129,39912,59182, etc); 

while(++$i -lt $idx.count) 
{
	$br[$idx[$i]] = 0x23	# Change modified byte back to original '#' character, 
				# for each index location.
}

# End of repair code example.
--------------------------------------------------------------------------------------------------

# (3) The C++ program has 'encrypted' the media file with simple XOR. 
# Decrypt it here.

Write-Host "Decrypting Media File...";

$j = 704;	# $j variable value is set as the 704th character index location of the PNG file.

for($i = $tr; $fl + $tr -gt $i;){ 		# Start 'for loop' at index location $tr, the start index of user data file,
						# until we reach $fl File Length value of user file.
						
	$bt[$i] = $bt[$i] -bxor $bt[$j];	# XOR each character $bt[$i} of user data file against character $bt[$j]
	$i++;
	$j--;
	if($j -lt 3) {
		$j = 704}			# Reset $j back to the 704th index location once the value is less than 3
	};
	
--------------------------------------------------------------------------------------------------

Clear-Host

$trunc=$bt[$tr..($fl + $tr -1)];  	# (4) $trunc now contains the user media file. 
					# $bt array contains whole PNG file, $tr start index of embedded user file, $fl File Length of user file
					
Remove-Item $pn;			# (5) Remove "pdvps_tmp.ps1" file.

$mp=$pn.Replace($n, $m);

if(Test-Path -Path $mp)			# If there already exists a 'pdvps_extracted' folder containing a 'media_file', delete it.
	{Remove-Item -Path $mp -Force;
	Start-Sleep -Seconds 1};
	
if($ver -gt 5) {
	Set-Content -value $trunc -AsByteStream -path "$($mp)"}		# (6) Write the contents of $trunc (user media file) to disk.
else{
	Set-Content -value $trunc -encoding byte -path "$($mp)"};	# (6) Write the contents of $trunc (user media file) to disk.

--------------------------------------------------------------------------------------------------

# (7) Running the extracted user file requires different methods depending on file type and operating system.
# Open extracted file on Linux... 

# Is it a Python or PowerShell file? Is it an executable file? Or is it something else?
# $m variable is the extracted media file name.

if($os -eq 'Linux'){
	if($app){ 

		# (7) Python or Powershell? 
		# ($app ="python3" or "pwsh", depending on file extension)
		# ($la Linux arguments, command-line arguments string variable) 

		$app+$m,$la |sh;	# e.g. "python3 media_file.py <arguments>"
					# e.g. "pwsh media_file.ps1 <arguments>"
					# |piped to the sh command.
		Write-Host} 	

	elseif($ext -eq '.exe'){
		chmod +x $m;
		iex ./$m$la	# (7) .exe (Invoke-Expression, iex)
				# e.g "Invoke-Expression ./media_file.exe <arguments>
	}
	else{
		chmod -x $m;
		ii $m}}		# (7) Anything else (Invoke-Item, ii)
				# e.g. "Invoke-Item media_file.mp3"

# (7) Open extracted file on Windows...

# Is it a Python or PowerShell file? Is it an executable file? Or is it something else?
# $m variable is the extracted media file name.

else{
	if($app){

		# (7) Python or PowerShell? 
		# ($app ="python3" or "powershell", depending on file extension
		# ($wa Windows arguments, command-line arguments string variable)

		&cmd /c $app$m$wa;	# e.g. "&cmd /c python3 media_file.py <arguments>"
					# e.g. "&cmd /c powershell .\media_file.ps1 <arguments>"

		Write-Host;
		Pause   	
		}
		elseif($ext -eq '.exe'){

			# (7) .exe (run this directly without need of any other command)

	 		&cmd /c $m$wa;	# e.g. "&cmd /c media_file.exe <arguments>"

			Write-Host;
			Pause   
		}
	else{ii $m}}	# (7) Anthing else (Invoke-Item, ii)
			# e.g. "Invoke-Item media_file.pdf"

<# End of PowerShell script (Start comment-block, ignore what follows...)
